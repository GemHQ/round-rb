
require "yaml"
require_relative "setup"

include CoinOp::Encodings
include CoinOp::Crypto

MultiWallet = CoinOp::Bit::MultiWallet

unless File.exists? "demo_wallet.yaml"
  puts
  puts <<-MESSAGE
  This script requires output from demo_account.rb, which will be
  found in ./demo_wallet.yaml.
  Run demo_account.rb first, then fund the address provided using
  a testnet faucet.  Once the transaction has 6 confirmations,
  you should be able to run this script.
  MESSAGE
  exit
end

data = YAML.load_file "demo_wallet.yaml"
api_token, passphrase =
  data.values_at :api_token, :passphrase

service_url = ARGV[0] || "http://localhost:8999/"
BV = BitVault::Client.discover(service_url) { BitVault::Client::Context.new }

## Create a "sub-client" with its own context

client = BV.spawn
client.context.set_token(api_token)

wallet = client.resources.wallet(data[:wallet][:url]).get

## Use the server's response data to construct a MultiWallet
#
# This models what an application would do in any subsequent interactions.
# The MultiWallet will be used later in this script to verify and sign a
# transaction.

wallet.primary_private_seed.iterations = wallet.primary_private_seed.iterations.to_i

primary_seed = PassphraseBox.decrypt(passphrase, wallet.primary_private_seed)
client_wallet = MultiWallet.new(
  :private => {
    :primary => primary_seed
  },
  :public => {
    :cosigner => wallet.cosigner_public_seed,
    :backup => wallet.backup_public_seed
  }
)

account = client.resources.account(data[:account][:url]).get


## Request a payment of bitcoins from this account back to the faucet address.

# faucet donation address mwwhVPiopW6HhhDtcSv3MUFLTB5ehhkgZg
unsigned_payment = account.payments.create(
  :outputs => [
    {
      :amount => 2_000_000,
      # faucet donation address
      :payee => {:address => "mwwhVPiopW6HhhDtcSv3MUFLTB5ehhkgZg"}
    }
  ]
)

log "Unsigned payment", unsigned_payment


## Reconstruct the transaction for signing.
#
# The unsigned payment record contains all the information needed for the
# client to reconstruct and sign the Bitcoin transaction without needing to
# search the blockchain for the inputs' previous transactions.  For the
# highest achievable level of security, of course, clients must search an
# independently maintained blockchain for the previous transactions.
#
# In practice, some users may not judge this to be necessary.  So long as the 
# client verifies all the output addresses and values are correct, the
# multiple-signature approach makes it impossible for a cosigning service to
# steal bitcoins by this approach.
#
# The only realistic attack by the cosigning
# service would be to falsify the values of the inputs, which cannot plausibly
# benefit the service.  If the selected inputs do not contain enough bitcoin
# to fund the transaction, nothing happens except a waste of everybody's time;
# the transaction is invalid and the Bitcoin network will reject it.
#
# If the selected outputs contain more substantially bitcoin than required to
# fund the transaction, the service could report lower values, then calculate
# the amount to send to the change address based on the falsified inputs.  But
# the only result of this would be to grant an exorbitant transaction fee to
# whichever miner solves the next block.

transaction = CoinOp::Bit::Transaction.data(unsigned_payment)


## Sign the transaction inputs
#
# Transaction inputs are really references to the outputs of previous
# transactions.  All bitcoins belonging to a BitVault account were paid
# to P2SH-Multisig addresses generated by the three-tree MultiWallet
# described earlier.  Thus the client must know the wallet path used
# to generate the address for each previous output.  We include this
# in the output metadata supplied as a part of each transaction input.
#
# We include the wallet path in the output for the change address, as well,
# so that the client can verify the address belongs to the correct wallet.
#
# Given an input and the corresponding wallet path, the client selects
# the correct "primary" private key and signs the input.

unless client_wallet.valid_output?(transaction.outputs.last)
  raise "bad change address"
end


## Send the input signatures back to the server
#
# When the server receives the signatures for a transaction, it will verify
# them and check which of the MultiWallet private keys was used for each.
# We expect the "primary" key to be used for all normal transactions;
# when the "backup" key is used, we take that as a signal that something
# has gone wrong, and we impose account restrictions until we have
# communicated with the wallet owner.
#
# After verifying all the input signatures, the server signs each with its
# own private "cosigner" keys, relays the transaction to the network,
# then sends the fully signed transaction record back to the client.

signed_payment = unsigned_payment.sign(
  :transaction_hash => transaction.hex_hash,
  :inputs => client_wallet.signatures(transaction)
)

log "Signed payment", mask(signed_payment, :status, :hash)


# The client will then be able to check the confirmation status of the signed
# payment.  Exact API to be determined.  To mitigate the need for polling, the
# service will post transaction statuses to the application's callback_url,
# if supplied.

log "Check transaction confirmations at http://tbtc.blockr.io/tx/info/#{signed_payment[:hash]}"




